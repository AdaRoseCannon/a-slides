---
layout: slide
title: Long Form Notes
---
<div class="marked" style="padding:2em; overflow: scroll; height: 100%;">

# To add

Include 6doam and Sound bunny as iframe examamples discuss what was done to make them fast.

----------

This talk covers animation both in the DOM and pratises which can also apply to general animation in the web.

In the Browser we have a goal to reach 60fps, which gives us 16ms to render a single frame.  
Jank is when the frame takes longer to layout and render than 16ms.
It causes a stutter, which feels bad.  
A long frame is caused by slow, synchronous main thread activity this can be most simply a long main thread loop in javascript or blocking io (e.g. synchronous XHR or large local storage transactions).

However most commonly it is caused by the layouts and paints used to render the page.

The ideal feeling is one of native that their very expensive device is not struggling to display simple a web page.

---------

üê¢ Layout is slowest. Layout is where the browser calculates the positions and sizes of all the elements in the page. Making a small DOM change could potentially invalidate the entire DOM tree causing it to be recalculated. An invalidated DOM is recalculated whenever a layout property is read as well as when each frame is rendered. If an element's layout needs to be recalculated it also has its bitmap in memory invalidated, so it needs to be repainted.

üê¢ Paint is medium-slow. This is where the layer's bitmap has been invalidated and needs to be redrawn and stored in memory. Aside from when its layout changes this will also happen when its appearance changes, such as background or color. Elements which need to be repainted will only be repainted once per frame.

üê∞ Composite is very fast. Composite only involves the graphics card rerendering from bitmaps calculated in paint and stored in memory: it is performed once per frame. It is triggered by gfx card-only operations such as transform, clipping and opacity.

<a href="http://csstriggers.com/" target="_blank">CSS triggers</a> is a great resource for discovering how properties trigger each of these operations.

Writing to DOM is free; you can write as much as you want.
Once the DOM is read if it has been invalidated the layout needs to be recalculated, which is expensive.
One common problem is reading, then writing in a loop, which is known as thrashing the DOM; the layout is invalidated and recalculated on every single read.
Interleaving reads and writes could mean multiple layout operations per frame

{% highlight js %}
el.height = (myVar + 1) + "px"
myVar = el.clientHeight;
el.height = (myVar + 1) + "px"
myVar = el.clientHeight;
el.height = (myVar + 1) + "px"
myVar = el.clientHeight;
el.height = (myVar + 1) + "px"
myVar = el.clientHeight;
{% endhighlight %}

Animating properties which cause layouts on the DOM will trigger a layout on every frame. In the slides I've put in some examples of bad practise where I naively do css animations on the width property.

{% highlight css %}
@keyframes bad {
	0% {width: 1.5em;}
	50% {width: 4em;}
	100% {width: 1.5em;}
}
{% endhighlight %}

The fix for the first situation tends to be fairly simple: batch your reads and write all together. Don't change a property then immediately read it.
E.g.Don't append to an `innerhtml` in a loop INSTEAD add it to a separate string and update the `innerHTML` in one go.

In an mvc or a large framework with many independent modules it can be difficult to ensure modules do not interleave read and writes. Wilson Page's <a href="https://github.com/wilsonpage/fastdom" target="_blank">fastdom library</a> can help with this so that reads and writes in a single frame all get done together.

***A good general motto is to calculate all DOM changes first then apply them in a single step.***

# Why is layout so hard on the browser?
One of the primary reasons is that type is really difficult to render and flow. It's very easy to take type for granted because type is everywhere on the web.

## What about paint why is it difficult?
Paint is difficult because it involves the cpu rerendering many bitmaps and storing them in memory.

## How come compositing is so fast then?
Rotating or scaling is all done off the main thread on the your phone/desktop's graphics chip and graphics cards are very good at applying transforms. 

# Layout Boundaries and Containment

Even though this modal <a href="https://www.1am.club/~ada/ews-slides/#slide-4" target="_blank">(Slide 4)</a> looks isolated the browser may still relayout the whole Dom.
However, we can seperate its DOM invalidation from the rest of the page.
Doing so doesn't accelerate the animation, but it does make the layout change less catastophic.

There is a draft css spec called <a href="http://dev.w3.org/csswg/css-containment/" target="_blank">containment</a> which will hint to the browser in much the same way as the will-change property that this element will not affect the rest of the DOM tree.
The containment spec requires certain properties, such as no scrolling and fixed dimensions.

{% highlight css %}
{
    height: <fixed value>;
    width: <fixed value or a %>;
    overflow: hidden;
    position: absolute;
    contain: strict; // In draft
}
{% endhighlight %}

NEED TO UPDATE PROGRESS OF CONTAIN - DO I INCLUDE IT AT ALL??!!

Containment could be done in browsers previously, but it relied on the element having certain properties before it would have layout boundaries, such as a fixed height and no scroll and relied upon the browser's implementation.

Containment is really good because it makes explicit as a performance enhancement what was previously a full set of properties. The performance gains from these could not be relied upon in every browser and using styling hacks for perf feels messy.

Containment will enforce the styling neccessary for the performance which means it could potentially collapse down a box without a height and width set (either to 300px x 150px or to 0 x 0). It will clip all content outside of itself.

***Note:*** Layout Containment is _not_ style containment as defined in the web components spec.  Style containment stops custom elements styling affecting other elements; layout containment is a css property in draft to aid performance by allowing the browser to isolate elements from the rest of the DOM's layout tree.

# How to be fast.

Consider the main thread as the thread which handles rendering. Whether writing a webapp or a 2D canvas game or 3D VR experience. 

# Synchronous IO operations

Of the older webapis which are synchronous Local Storage is probably the most commonly still used. There are several situations where it can be slow:

http://www.stevesouders.com/blog/2014/02/11/measuring-localstorage-performance/ 

Although recent tests on Cr45 for mobile and desktop show that performance is about 1/3 of writing to memory. It may be best to use an async storage such as IndexedDB.

# CPU intensive tasks

When the page looks like it is ready to be used it should also be readily responding to a users interactions.

Parsing JS and decoding images can also quite extensive. Although it's great to have everything cached before the user needs it. Front loading everything is a great way to make the user's first impressions really awful. 

Especially if there initial landing is before your UI interaction scripts are ready and all they have is a pretty picture of your above the fold content. 

Parsing a large JSON file is slow. Download it in your SW so it is off the main thread then query it as needed.

If you need to query a large JSON file but don't _need_ all the data right there and then. Instead break it into chunks and load a bit each frame.

Or load it all in the service worker, message the SW to pull out the bits you need.

Phyically accurate snow flakes on your christmas themed website. Use a worker for stuff like this. Many libraries for Verlet Integration and Physics will run just as well in a worker.
A nice interface is to write a wrapper which returns promises for your physics objects, (have example now works in Cr45 and FF).

Pattern for promise based worker handling.

Tween your own animations:

Tween.js rules!

Main thread:

{% highlight js %}
function workerMessage(message) {

	// This wraps the message posting/response in a promise, which will resolve if the response doesn't
	// contain an error, and reject with the error if it does. If you'd prefer, it's possible to call
	// controller.postMessage() and set up the onmessage handler independently of a promise, but this is
	// a convenient wrapper.
	return new Promise(function(resolve, reject) {
		const messageChannel = new MessageChannel();
		messageChannel.port1.onmessage = function(event) {
			if (event.data.error) {
				messageChannel.port1.onmessage = undefined;
				reject(event.data.error);
			} else {
				messageChannel.port1.onmessage = undefined;
				resolve(event.data);
			}
		};

		// This sends the message data as well as transferring messageChannel.port2 to the service worker.
		// The service worker can then use the transferred port to reply via postMessage(), which
		// will in turn trigger the onmessage handler on messageChannel.port1.
		// See https://html.spec.whatwg.org/multipage/workers.html#dom-worker-postmessage
		myWorker.postMessage(message, [messageChannel.port2]);
	});
}

workerMessage({
	action: 'doThing',
	myVar: 4
})
.then(data => {
	console.log(data.response);
});
{% endhighlight %}

Worker:

{% highlight js %}

// Recieve messages from the client and reply back onthe same port
self.addEventListener('message', function(event) {
		Promise.resolve()
		.then(function () {

			switch(event.data.action) {

				case 'doThing':
					event.data.result = expensiveThing();

				default:
					throw Error('Invalid Action');
			}
		})
		.then(function () {
			event.data.success = true;
		}, function (err) {
			console.error(err);
			event.data.success = false;
			if (err) {
				event.data.message = err.message ? err.message : err;
			}
		})
		.then(function () {
			event.ports[0].postMessage(event.data);
		});
});
{% endhighlight %}

# WebGL Shaders

If working with WebGL and are animating a fixed topology e.g. Waves, Data Displays. Do the vertex transforms in the vertex shader rather than calculating a buffer geometry on the cpu, you will get much better performance. E.g. sound bunny.

## Super crazy (don't do this),

If you want to do calculations and take advantage of the graphics card ability for vector arithmatic and float handling. You can write a glsl shader for your calculation render it to a framebuffer then use glReadPixels. Process the raw byte data to get actual numbers.

### SIMD if working with intel's xdk

# For rendering games

* Don't render what is off screen, set your draw distance to something reasonable.
* Calculate physics as you need it. Don't run physics where the user won't notice it.
* Even if you are running physics in a worker don't want to overheat the phone.

### Image of users face melting off in vr

Don't try optimising this for DOM the browser will take care of this.

# Make it feel fast,

* Make sure scrolling is responsive
* Make it behave from the moment the page is loaded.
* An app interstitial that doesn't have working x button because the js load is a great way to get users to bounce.

# References
* <a href="http://dev.w3.org/csswg/css-containment/" target="_blank">Containment Spec</a>
* <a href="https://github.com/wilsonpage/fastdom" target="_blank">Fastdom - Library to avoid read/write loop</a>
* <a href="http://csstriggers.com/" target="_blank">CSS Triggers</a>
* <a href="https://css-tricks.com/things-chrome-dev-summit-2014/" target="_blank">Great Paul Lewis talk</a>
* <a href="http://lanyrd.com/2015/extwebsummit/" target="_blank">2015 Extensible Web Summit.</a>

</div>
