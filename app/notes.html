---
layout: slide
title: Long Form Notes
---
<div class="marked" style="padding:2em; overflow: scroll; height: 100%;">

This talk covers animation both in the DOM and pratises which can also apply to general animation in the web.

In the Browser we have a goal to reach 60fps, which gives us 16ms to render a single frame.  
Jank is when the frame takes longer to layout and render than 16ms.
It causes a stutter, which feels bad.  
A long frame is caused by slow, synchronous main thread activity this can be most simply a long main thread loop in javascript or blocking io (e.g. synchronous XHR or large local storage transactions).

However most commonly it is caused by the layouts and paints used to render the page.

---------

üê¢ Layout is slowest. Layout is where the browser calculates the positions and sizes of all the elements in the page. Making a small DOM change could potentially invalidate the entire DOM tree causing it to be recalculated. An invalidated DOM is recalculated whenever a layout property is read as well as when each frame is rendered. If an element's layout needs to be recalculated it also has its bitmap in memory invalidated, so it needs to be repainted.

üê¢ Paint is medium-slow. This is where the layer's bitmap has been invalidated and needs to be redrawn and stored in memory. Aside from when its layout changes this will also happen when its appearance changes, such as background or color. Elements which need to be repainted will only be repainted once per frame.

üê∞ Composite is very fast. Composite only involves the graphics card rerendering from bitmaps calculated in paint and stored in memory: it is performed once per frame. It is triggered by gfx card-only operations such as transform, clipping and opacity.

<a href="http://csstriggers.com/" target="_blank">CSS triggers</a> is a great resource for discovering how properties trigger each of these operations.

Writing to DOM is free; you can write as much as you want.
Once the DOM is read if it has been invalidated the layout needs to be recalculated, which is expensive.
One common problem is reading, then writing in a loop, which is known as thrashing the DOM; the layout is invalidated and recalculated on every single read.
Interleaving reads and writes could mean multiple layout operations per frame

{% highlight js %}
el.height = (myVar + 1) + "px"
myVar = el.clientHeight;
el.height = (myVar + 1) + "px"
myVar = el.clientHeight;
el.height = (myVar + 1) + "px"
myVar = el.clientHeight;
el.height = (myVar + 1) + "px"
myVar = el.clientHeight;
{% endhighlight %}

Animating properties which cause layouts on the DOM will trigger a layout on every frame. In the slides I've put in some examples of bad practise where I naively do css animations on the width property.

{% highlight css %}
@keyframes bad {
	0% {width: 1.5em;}
	50% {width: 4em;}
	100% {width: 1.5em;}
}
{% endhighlight %}

The fix for the first situation tends to be fairly simple: batch your reads and write all together. Don't change a property then immediately read it.
E.g.Don't append to an `innerhtml` in a loop INSTEAD add it to a separate string and update the `innerHTML` in one go.

In an mvc or a large framework with many independent modules it can be difficult to ensure modules do not interleave read and writes. Wilson Page's <a href="https://github.com/wilsonpage/fastdom" target="_blank">fastdom library</a> can help with this so that reads and writes in a single frame all get done together.

***A good general motto is to calculate all DOM changes first then apply them in a single step.***

### Animating an interaction which causes a lot of change to the layout.

Let's say we have a widget in which notifications get appended. <a href="https://www.1am.club/~ada/ews-slides/#slide-3" target="_blank">(Slide showing the notification example)</a> As a new element gets added the widget grows in height.  
We want to animate prepending an element to the start.
Here we have an issue because the height changes which pushes many elements around the page,
so it's expensive because it's a layout operation and much worse because the whole page will change so layout needs to be performed on the entire document.

But following our advice from earlier before we insert the new notification we can measure how everything will change then animate that change. (Click twice to demo the smooth interaction)

When doing something like this it is best to front load all of the dom read/writes so the app is responsive as the animation finishes.

If doing a DOM change on a user interaction then you have about a whole 100ms (~6 frames) to measure and write to the DOM before it feels sluggish. Which is plenty of time to perform these measurements.
This method follows up from a great talk given by Paul Lewis ([@aerotwist](https://twitter.com/aerotwist)) at the Chrome Dev Summit.

(Next example in the slides follows this through step by step)

 > ### Note:

 REWRITE THIS BUT USING TWEEN.JS THE PRACTICE IS GOOD BUT THE EXAMPLE DOES NOT WORK

* Measure every element we want to animate.
* Store the current animation so it can be restored later set it to ‚Äò0s‚Äô
* Store the current transform so it can be restored later
* Perform the function
* Measure the new positions, sizes,
* Anything which has changed size: scale it and all give all of its children the inverse transform.
* Give all the children the offset of the top left of the parent
* Give them the inverse scale
* Apply the translations to move everything to its new place
* Apply the new transition to everything affected
* Set all of the transforms to their original values
* Watch everything smoothly animate.
* On transitionend
* Restore the transitions
* Fire any callbacks

# Layout Boundaries and Containment

Even though this modal <a href="https://www.1am.club/~ada/ews-slides/#slide-4" target="_blank">(Slide 4)</a> looks isolated the browser may still relayout the whole Dom.
However, we can seperate its DOM invalidation from the rest of the page.
Doing so doesn't accelerate the animation, but it does make the layout change less catastophic.

There is a draft css spec called <a href="http://dev.w3.org/csswg/css-containment/" target="_blank">containment</a> which will hint to the browser in much the same way as the will-change property that this element will not affect the rest of the DOM tree.
The containment spec requires certain properties, such as no scrolling and fixed dimensions.

{% highlight css %}
{
    height: <fixed value>;
    width: <fixed value or a %>;
    overflow: hidden;
    position: absolute;
    contain: strict; // In draft
}
{% endhighlight %}

NEED TO UPDATE PROGRESS OF CONTAIN - DO I INCLUDE IT AT ALL??!!

Containment could be done in browsers previously, but it relied on the element having certain properties before it would have layout boundaries, such as a fixed height and no scroll and relied upon the browser's implementation.

Containment is really good because it makes explicit as a performance enhancement what was previously a full set of properties. The performance gains from these could not be relied upon in every browser and using styling hacks for perf feels messy.

Containment will enforce the styling neccessary for the performance which means it could potentially collapse down a box without a height and width set (either to 300px x 150px or to 0 x 0). It will clip all content outside of itself.

***Note:*** Layout Containment is _not_ style containment as defined in the web components spec.  Style containment stops custom elements styling affecting other elements; layout containment is a css property in draft to aid performance by allowing the browser to isolate elements from the rest of the DOM's layout tree.

# Synchronous IO operations

Of the older webapis which are synchronous Local Storage is probably the most commonly still used. There are several situations where it can be slow:

http://www.stevesouders.com/blog/2014/02/11/measuring-localstorage-performance/ 

Although recent tests on Cr45 for mobile and desktop show that performance is about 1/3 of writing to memory. So don't do it in a crazy loop and you'll be fine.

# CPU intensive tasks

Phyically accurate snow flakes on your christmas themed website. Use a worker for stuff like this. A nice interface is to write a wrapper which returns promises, (have example now works in Cr45 and FF).

Pattern for promise based worker handling.

Tween your own animations:

Tween.js rules!

Main thread:

{% highlight js %}
function workerMessage(message) {

	// This wraps the message posting/response in a promise, which will resolve if the response doesn't
	// contain an error, and reject with the error if it does. If you'd prefer, it's possible to call
	// controller.postMessage() and set up the onmessage handler independently of a promise, but this is
	// a convenient wrapper.
	return new Promise(function(resolve, reject) {
		const messageChannel = new MessageChannel();
		messageChannel.port1.onmessage = function(event) {
			if (event.data.error) {
				messageChannel.port1.onmessage = undefined;
				reject(event.data.error);
			} else {
				messageChannel.port1.onmessage = undefined;
				resolve(event.data);
			}
		};

		// This sends the message data as well as transferring messageChannel.port2 to the service worker.
		// The service worker can then use the transferred port to reply via postMessage(), which
		// will in turn trigger the onmessage handler on messageChannel.port1.
		// See https://html.spec.whatwg.org/multipage/workers.html#dom-worker-postmessage
		myWorker.postMessage(message, [messageChannel.port2]);
	});
}

workerMessage({
	action: 'doThing',
	myVar: 4
})
.then(data => {
	console.log(data.response);
});
{% endhighlight %}

Worker:

{% highlight js %}

// Recieve messages from the client and reply back onthe same port
self.addEventListener('message', function(event) {
		Promise.resolve()
		.then(function () {

			switch(event.data.action) {

				case 'doThing':
					event.data.result = expensiveThing();

				default:
					throw Error('Invalid Action');
			}
		})
		.then(function () {
			event.data.success = true;
		}, function (err) {
			console.error(err);
			event.data.success = false;
			if (err) {
				event.data.message = err.message ? err.message : err;
			}
		})
		.then(function () {
			event.ports[0].postMessage(event.data);
		});
});
{% endhighlight %}

# WebGL Vertex Shaders

If working with WebGL and are animating a fixed topology e.g. Waves, Data Displays. Do the vertex transforms in the vertex shader rather than calculating a buffer geometry on the cpu, you will get much better performance. E.g. sound bunny.

# SIMD if working with intel's xdk

# References
* <a href="http://dev.w3.org/csswg/css-containment/" target="_blank">Containment Spec</a>
* <a href="https://github.com/wilsonpage/fastdom" target="_blank">Fastdom - Library to avoid read/write loop</a>
* <a href="http://csstriggers.com/" target="_blank">CSS Triggers</a>
* <a href="https://css-tricks.com/things-chrome-dev-summit-2014/" target="_blank">Great Paul Lewis talk</a>
* <a href="http://lanyrd.com/2015/extwebsummit/" target="_blank">2015 Extensible Web Summit.</a>

</div>
